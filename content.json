{"pages":[{"title":"404","text":"","path":"404/index.html","date":"01-13","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"01-13","excerpt":""},{"title":"about","text":"","path":"about/index.html","date":"01-13","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"01-13","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"01-13","excerpt":""}],"posts":[{"title":"搭建 React 项目开发环境","text":"第一步: 初始化 新建文件目录并进入 yarn init 初始化 下载 webpack yarn add webpack --dev 此时目录结构为 ┌ node_modules ├ src | ├ index.js └ package.json 第二步 配置 webpack 创建 webpack 的配置文件 webpack.config.js 并添加以下代码 const path = requier(&quot;path&quot;); module.exports = { entry: &quot;./src/index.js&quot;, // 入口文件路径 output: { // 出口 path: path.join(__dirname, &quot;dist&quot;), // 出口文件路径 filename: &quot;build.js&quot; // 出口文件名 } } 第三步 编译 JSX此时的文档还不支持 JSX 语法，所以我们需要通过 babel 来编译它。通过下载以下插件来达到我们的目的: yarn add @babel/preset-react @babel/preset-env @babel/core babel-loader@8.0.0-beta.0 --dev 下载好之后创建 .babelrc 文件，并写入以下内容: { &quot;presets&quot;: [ &quot;@babel/present-env&quot;, &quot;@babel/present-react&quot; ] } 然后修改 webpack 的配置文件 webpack.config.js，在配置出口文件的下方添加以下内容: module: { loaders: [ { test: /\\.js$/, // 正则判断是否为 js 文件 loader: &quot;babel-loader&quot;, // 使用 babel-loader exclude: /node_modules/ // 除 node_modules 以外编译 } ] } 现在我们已经支持了 js 文件的编译打包，下面来配置下 有关 css 和图片的相关配置吧。 下载 style-loader, css-loader 用来支持 css 文件打包 yarn add style-loader css-loader --dev 下载 url-loader 来支持图片的引入 yarn add url-loader --dev 然后在配置文件中的 loaders 中添加 { test: /\\.css$/, // 正则判断是否为 css 文件 loader: [ &quot;style-loader&quot;, &quot;css-loader&quot; ] // 使用 style-loader 和 css-loader }, { test: /\\.png$|\\.jpg$|\\.jpeg$|\\.svg/, loader: &quot;url-loader&quot; } 最后我们只需要在 index.js 中引入就可以了 import css from &quot;./index.css&quot; 此时我们已经基本配置好 React 的开发环境了。但是下面的内容会让我们的开发过程更加舒服。 让我们来下载 html-webpack-plugin 用以将打包之后的文件自动插入到需要的模板中 yarn add http-webpack-plugin --dev 下载后在 webpack.config.js 中引入 const HTMLWebpackPlugin = require(&quot;http-webpack-plugin&quot;) 然后在 module 块下方添加: plugins: [ new HTMLWebpackPlugin({ template: &quot;./index.html&quot;, // 模板路径 filename: &quot;index.html&quot;, // 文件名 title: &quot;首页&quot;, // 标题 inject: &quot;body&quot; // 选择插入的位置 }) ] 现在我们已经实现了半自动了，可是我们还想全自动。怎么办呢？ 下载 webpack-dev-server 让它支持热更新 yarn add webpack-dev-server --dev 此时我们直接运行可能会出现报错，不用担心，只需要修改下 package.json 文件，在设置协议的下方添加: &quot;scripts&quot;: { &quot;start&quot;: &quot;webpack-dev-server&quot; } 现在我们离成功只有一步之遥了，最后下载一下 react 和 react-dom ，然后在我们的 index.js 文件中引入，就可以正常使用啦。 yarn add react react-dom 现在 npm start 来运行吧~","path":"2018/02/07/简单搭建React开发环境/","date":"02-07","excerpt":""},{"title":"","text":"","path":"2018/02/07/简单搭建React开发环境~/","date":"02-07","excerpt":""},{"title":"React笔记","text":"属性与状态什么是属性？props = properties 在英文中的意思就是属性。 属性的意思就是:一个事物的性质与关系。属性往往是与生俱来的，无法自己改变。在 React 中，我们可以简单的理解为: 属性是不可以修改的，准确说属性是不可以由组件自己进行修改的，组件的属性是由父组件传递进来的，相当于在组件出生的时候自己带的一些特性，这些是它自己无法决定的。 属性的用法:一、在调用组件时，直接传入一个键值对 &lt;HelloWorld name= ? /&gt; 在这里，键就是等号左边的 name 也就是属性的名，等号右边也就是传入的属性值。在等号右边可以写很多种内容。例: “Tim”, {123}, {[1, 2, 3]}, {variable} 二、展开，列如: var props = { one: &quot;123&quot;, two: 321 } &lt;HelloWorld {...props} /&gt; 首先，我们定义一个对象 props，对象中有两个属性，一个属性是 one，一个属性是 two，他们的值分别为字符串、数字。如果我们采用第一种键值对的命名方式，那么我们就需要写两个键值对，一个是 one = { props.one } ，第二个是 two = { props.two }，这样写起来比较麻烦，而且如果我们修改了 props 中的内容，就需要去修改属性中对应的赋值，这样降低了可维护性，并无法动态设置属性。 利用展开方法，React 就会自动把对象中的属性和值当做属性的赋值，所以 &lt;HelloWorld /&gt; 拿到的其实是两个属性，一个是 one，一个是two。假如我们把对象前 ... 删掉，这样拿到的就是一个 props 对象，它还需要从中取出内部的属性和值。 三、setProps var instance = React.render( &lt;HelloWorld&gt;&lt;/HelloWorld&gt;, document.body ); instance.setProps({ name: &quot;Tim&quot; }); 利用 React 提供的 setProps 函数，就像使用 setState 函数设置组件状态一样，setProps 可以设置组件的属性。setProps 接收的参数是一个对象，它会用这个对象来更新属性，但是在实际使用中并不常用。因为在组件内部修改属性违背了 React 的设计原则。在组件外部的话使用上面两种方式能更加方便的修改属性。 什么是状态？在 React 中，使用 this.state 来引用。state 本身就是状态的意思，所以不需要缩写。状态是指: 事物所处的状况。状况也就是环境，是不断变化的，所以状态也是不断变化的。 需要注意的是: 状态是由事物自行处理的，不断变化的。跟属性不一样，属性是天生具备的，事物没办法去直接修改。但是状态是事物可以直接进行操作的。 在 React 中，状态是事物的私有属性，一个事物的状态怎么样，都是由事物自己去决定的，他的父组件和子组件都没有权利也没有能力去修改它的状态。 状态的用法:一、constructor: 初始化每个实例特有的状态二、setState: setState 是 React 提供的函数，通过它可以更新组件的状态。 相比属性来说，状态的用法比较简单。 属性与状态的对比通过上面我们了解到了属性和状态的含义和用法。那么属性和状态有什么相似点或者不同点呢？ 属性和状态的相似点: 都是纯JS对象 他们都会触发 render 更新组件 都具有确定性 第一种: 纯 JS 对象，就是JS原生对象，在JS中还有宿主对象，例如 window，其实就是浏览器提供的宿主对象，并不是原生对象。属性和状态就是 JS 原生对象。 第二种: 状态和属性的变化都会触发 render 的更新。属性和状态的改变都会触发组件的整个流程，从处理属性到是否应该更新，到进行对比到最后的render 更新，会触发很多函数，我们可以在不同的函数中进行不同的操作。 第三种: 属性和状态都具有确定性。状态相同结果一定相同。也就是说给定了相同的状态或者属性，组件生成的应该都是相同的代码。 属性和状态的对比: - 属性 状态 能否从父组件获取初始值？ √ × 能否由父组件修改？ √ × 能否在组件内部设置默认值？ √ √ 能否在组件内部修改？ × √ 能否设置子组件的初始值？ √ × 能否修改子组件的值？ √ × 区分属性和状态有一种简单的办法: 就是看属性和状态保存的数据是否需要在运行时修改，如果运行时组件需要修改这个数据，那么这个数据就一定是状态。除此之外的所有数据都可以设置为属性。 元素与组件元素:React 中，元素是最小的基本单位，使用 JSX 语法可以创建一个 React 元素。 const element = &lt;div className=&apos;element&apos;&gt;&lt;/div&gt; React 元素代表所有你在屏幕上看到的东西。React 通过读取这些元素来构建 DOM 并保持数据内容一致。React 元素不是真实的 DOM 元素，它仅仅是 js 的普通对象。也可以用 React.createElement() 方法来构建 React 元素。 组件:组件是什么？组件是由元素构成的，React 中使用组件来封装界面模块，整个界面就是一个大的组件，我们在开发过程中不断优化和拆分界面组件。 组件的类型React 推出后，由于不同的原因，出现了三种定义 React 组件的方式。 函数式定义的无状态组件 使用es5原生方式 React.createClass 定义的组件 使用es6形式的 extends React.Component 定义的组件 上面三种组件有什么区别呢？ 一、无状态组件 顾名思义，无状态组件就是无状态的组件。它是为了创建纯展示组件，这种组件只负责根据传入的 props 来展示，不涉及到 state 的操作。 function SayHello (props) { return &lt;div&gt;Hello, { props.name }&lt;/div&gt; } ReactDOM.render(&lt;SayHello name=&apos;Tom&apos; /&gt;, document.body) 无状态组件的创建让代码可读性更高，并且减少了更多的多余代码，只有一个 render 方法，极大的增强了编写组件的便利。由于是无状态组件，所以不会被实例化，这样也会让性能得到一定的提升。但是不能访问 this 对象，同样因为不需要组件生命周期管理和状态管理，所以该组件无法访问生命周期的方法。 二、React.createClass React.createClass 是 React 最开始推荐的创建组件的方式，使用ES5的JavaScript 来实现的 React 组件，同时也是三种方式最早，兼容性最好的方法。 var Greeting = React.createClass({ render: function() { return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;; } }); 与无状态组件相比，React.createClass 是创建有状态的组件，可以访问组件的生命周期方法，但是随着时间，也有一些问题暴露出来: 会自绑定函数方法，导致不必要的性能开销，增加代码过时的可能性。 React.createClass 的 mixins 不够自然、直观。相比它 React.Component 更适合高阶组件，并且由于高阶组件是纯净的JavaScript，所以不用担心它们会被废弃。 三、React.Component React.Component 是以ES6的形式来创建 React 组件的，是目前 React 推荐的创建有状态组件的方式。相比较与第二种方法，React.Component 可以很好的实现代码的复用。 class Greeting extemds React.Component{ render () { return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;; } };","path":"2018/01/31/React笔记/","date":"01-31","excerpt":""},{"title":"Rollup 新一代打包工具？","text":"什么是 Rollup?用 Rollup 团队自己的话来将是: Rollup 是下一代 JavaScript 模块打包工具。开发者可以在你的应用或库中使用 ES2015 模块，然后高效地将它们打包成一个单一文件用于浏览器和 Node.js 使用。 Rollup 的闪光点Rollup 最让我们程序猿激动的地方就是能让打包文件体积很小。小到什么地步呢？相比其他 JavaScript 打包工具，Rollup 能打包出更小、更快的包。因为 Rollup 是基于 ES2015 模块，比 CommonJS 模块机制更高效。正因如此，Rollup 的 tree-shaking 也变得更加容易( 只能对 ES 模块进行 tree-shaking )。然而 tree-shaking 并不是 Rollup 在与其他打包工具相比的唯一的优势。 由于 Rollup 很高效，Webpack2 也支持 tree-shaking 使用 Rollup 处理并打包 JavaScript 文件安装 Rollup:首先，新建一个文件夹并全局安装 rollup npm i -g rollup 下一步: 执行下列命令: npm init -ynpm i rollup 然后，在当前文件夹下新建 rollup.config.js 文件，并在文件添加以下内容: export default { entry: &apos;main.js&apos;, output: { file: &apos;main.min.js&apos;, format: &apos;cjs&apos; } } entry: 希望 Rollup 处理的文件路径。作为入口文件，初始化所有东西并启动应用。 file: 编译之后的文件存放的路径。 format: Rollup 输出格式。包括( amd / es6 / iife / umd ) 来看一下入口文件 main.js : import { cube } from &apos;./math.js&apos;; console.log( cube( 5 ) ); 被引入文件 math.js 为: export function square (x) { return x * x; } export function cube (x) { return x * x * x; } 通过 Rollup 打包之后为: &apos;use strict&apos;; function cube (x) { return x * x * x; } console.log( cube( 5 ) ); 这里可以明显的看到 Rollup 中 Tree-shaking 的作用了，在我们创建的 math.js 文件中并未用到的 square 方法，在使用 Rollup 打包之后被干掉了。 到这里，安装和文件都已经准备好了，让我们来运行它: ./node_modules/.bin/rollup main.js -f cjs 因为我们并没有使用配置文件，所以输入上述命令，打包之后的内容会显示在终端上。我们当然也可以使用配置文件: ./node_modules/.bin/rollup -c 如果你的配置文件名并不是 rollup.config.js 的话( 例如: ‘rollup.config.dev.js’ ) ./node_modules/.bin/rollup -c rollup.config.dev.js","path":"2018/01/30/Rollup/","date":"01-30","excerpt":""},{"title":"Less, Sass和Stylus","text":"Less, Sass和StylusLESSLESS 做为 CSS 的一种形式的扩展，在现有的 CSS 语法上，添加了很多额外的功能，拥有诸如 Sass 和 Stylus 之类的预处理器，它们也给我们提供了许多优于纯 CSS 的好处。 变量 - 它可以让你更轻松的在整个样式表中定义和更改值 Mixins - 可以让你重用或者组合样式，而且支持传递参数。 函数 - 它为你提供了一些方便的程序去操纵颜色，转换图像等。 变量我们可以用 @ 来声明一个变量来保存需要的样式 @nice-blue: #5B83AD;@light-blue: @nice-blue + #111; .header { color: @light-blue; } 转译输出后: .header { color: #6c94be; } 当然也可以用已定义的变量来为其他变量定义: @str: “I am str.”;@var: ‘str’;content: @@var; 转译输出后: content: “I am str.”; *请注意 LESS 中的变量为 “常量” ，所以只能定义一次.* 混合在 LESS 中我们可以将一些通用的属性集定义，然后在其他标签中去调用这个属性集. .border { border-top: solid 1px red; border-bottom: solid 2px black;} 那如果我们现在需要在其他标签中引入这个属性集，那么我们只需要在任何标签中调用就可以了: menu a { color: #111; .border;}.post a { color: red; .border;} .border 里面的属性样式就会在 #menu a 和 .post a中体现出来。转译输出后: menu a { color: #111; border-top: solid 1px red; border-bottom: solid 2px black;}.post a { color: blue; border-top: solid 1px red; border-bottom: solid 2px black;} 任何 CSS class, id 或者 元素 属性集都可以以同样的方式引入. 带参数混合在 LESS 中，你还可以像函数一样定义一个带参数的属性集合,它支持传入参数 .border-radius (@radius) { border-radius: @radius; -moz-border-radius: @radius; -webkit-border-radius: @radius;} 然后像这样调用: header { .border-radius(4px);}.button { .border-radius(6px);} 我们还可以给参数设置默认值: .border-radius (@radius: 5px) { border-radius: @radius; -moz-border-radius: @radius; -webkit-border-radius: @radius;} 所以现在如果像这样调用的话: header { .border-radius;} radius的值就会是5px. 嵌套 ul { background-color: #03A9F4; padding: 10px; list-style: none; li { background-color: #fff; border-radius: 3px; margin: 10px 0; }} 编译成 CSS 代码： ul { background-color: #03A9F4; padding: 10px; list-style: none;}ul li { background-color: #fff; border-radius: 3px; margin: 10px 0;} 就像在其它高级语言中一样， Less 的变量根据范围接受它们的值。如果在指定范围内没有关于变量值的声明， less 会一直往上查找，直至找到离它最近的声明。 StylusStylus 与 Less 同样是 css 的预处理器。它没有封号、花括号、逗号也是可以执行的。 例如： p margin 0 padding 0 编译后为： p { margin: 0; padding: 0;} 变量Stylus 中也可以将常用的参数定义为变量，在需要的地方直接引用变量即可 例如： font-size = 16px //单一变量font = 12px/16px ‘微软雅黑’ //变量表达式$width = 16px //可以带标示符 a font font //直接引用单一变量 width $width //直接引用变量表达式 margin-left (@width/2) //可以用@来访问该属性当前对应的值 转译后为： a { font: 0.75px ‘微软雅黑’; width: 16px; margin-left: 8px;} Stylus 中也可用 HTML 结构来表现 CSS 层级关系 body color red ul line-height 20px height 20px font-size 16px li display inline-block padding 10px border 1px solid #ccc text-align center a color red font-size 12px 转译后为： body { color: #f00;}body ul { line-height: 20px; height: 20px; font-size: 16px;}body ul li { display: inline-block; padding: 10px; border: 1px solid #ccc; text-align: center;}body ul li a { color: #f00; font-size: 12px;} SASSSASS 的使用与前两者大体相同，在 SASS 中我们也可以来声明一个变量 $base-gap: 10px;$base-color: #333;.test { margin-top: $base-gap; color: $base-color;} 在这里我们能看到 SASS 声明变量与 LESS 和 Stylus 还是有不同的，在LESS 中，我们用 @ 符号来声明一个变量，在 Stylus 中，我们也可以用 @ 符号或者什么都不用。而在 SASS中 我们需要用 $ 符号来声明变量 在 SASS 中有默认变量这一说法：如果这个变量被声明赋值了，那就用它声明的值，否则就用默认值。这在书写 SASS 库文件时非常有用。设置默认变量的方法也非常简单，只需在变量值后加上 !default $color: #ccc;$color: #000 !default;p { color: $color;} 嵌套方法 .list { margin-top: 10;}.list li { padding-left: 15px;}.list a { color: #333;}.list a:hover { text-decoration: none;} 用嵌套方法写就是： .list { margin-top: 10px; li { padding-left: 15px; } a { color: #333; &amp;:hover { text-decoration: none; } }} 嵌套代码中的 &amp; 表示父元素选择器。 下载方法LESS：npm install -g less 安装完成后，你将可以在任何打开的窗口中使用 lessc 命令，这个命令允许你将 .less 文件编译成纯 CSS 文件，像下面这样： lessc styles.less &gt; styles.css Stylus：npm install -g stylus 建立一个stylusExample/，再在里面建立 src 目录专门存放 stylus 文件，在里面建立 example.styl 文件。然后在 stylusExample 目录下面执行下面命令 stylus --compress src/ 输出 compiled src/example.css ，这个时候表示你生成成功了，带上 –compress 参数表示你生成压缩的CSS文件。 stylus --css css/example.css css/out.styl CSS转换成stylstylus help box-shadow CSS属性的帮助stylus --css test.css 输出基本名一致的.styl文件 SASSSass 基于 Ruby 编写，所以安装 Sass 分2步：先安装Ruby的环境，再安装Sass。 一、在 Ruby 官网选择电脑系统对应的版本下载、安装，建议默认路径即可。安装过程中注意勾选第二项：Add Ruby executablesto your PATH。安装完毕在命令行环境中通过 ruby -v 查看是否成功。 二、Ruby安装成功之后，它自带的包管理工具 gem 也就安装好了。直接打开命令行通过gem 执行 Sass 安装命令，再查看是否安装成功： gem install sass sass -v 查看是否安装成功 经过简单的了解和尝试后，我比较喜欢 Stylus 得益于以下几点： 简短直观，缩进让CSS的层次非常直观 @ 属性引用可以减少维护量 函数和Mixin，重用的利器","path":"2018/01/13/Less, Sass和Stylus/","date":"01-13","excerpt":""}]}