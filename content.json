{"pages":[{"title":"categories","text":"","path":"categories/index.html","date":"01-13","excerpt":""},{"title":"about","text":"","path":"about/index.html","date":"01-13","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"01-13","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"01-13","excerpt":""},{"title":"404","text":"","path":"404/index.html","date":"01-13","excerpt":""}],"posts":[{"title":"React笔记","text":"属性与状态什么是属性？props = properties 在英文中的意思就是属性。 属性的意思就是:一个事物的性质与关系。属性往往是与生俱来的，无法自己改变。在 React 中，我们可以简单的理解为: 属性是不可以修改的，准确说属性是不可以由组件自己进行修改的，组件的属性是由父组件传递进来的，相当于在组件出生的时候自己带的一些特性，这些是它自己无法决定的。 属性的用法:一、在调用组件时，直接传入一个键值对 &lt;HelloWorld name= ? /&gt; 在这里，键就是等号左边的 name 也就是属性的名，等号右边也就是传入的属性值。在等号右边可以写很多种内容。例: “Tim”, {123}, {[1, 2, 3]}, {variable} 二、展开，列如: var props = { one: &quot;123&quot;, two: 321 } &lt;HelloWorld {...props} /&gt; 首先，我们定义一个对象 props，对象中有两个属性，一个属性是 one，一个属性是 two，他们的值分别为字符串、数字。如果我们采用第一种键值对的命名方式，那么我们就需要写两个键值对，一个是 one = { props.one } ，第二个是 two = { props.two }，这样写起来比较麻烦，而且如果我们修改了 props 中的内容，就需要去修改属性中对应的赋值，这样降低了可维护性，并无法动态设置属性。 利用展开方法，React 就会自动把对象中的属性和值当做属性的赋值，所以 &lt;HelloWorld /&gt; 拿到的其实是两个属性，一个是 one，一个是two。假如我们把对象前 ... 删掉，这样拿到的就是一个 props 对象，它还需要从中取出内部的属性和值。 三、setProps var instance = React.render( &lt;HelloWorld&gt;&lt;/HelloWorld&gt;, document.body ); instance.setProps({ name: &quot;Tim&quot; }); 利用 React 提供的 setProps 函数，就像使用 setState 函数设置组件状态一样，setProps 可以设置组件的属性。setProps 接收的参数是一个对象，它会用这个对象来更新属性，但是在实际使用中并不常用。因为在组件内部修改属性违背了 React 的设计原则。在组件外部的话使用上面两种方式能更加方便的修改属性。 什么是状态？在 React 中，使用 this.state 来引用。state 本身就是状态的意思，所以不需要缩写。状态是指: 事物所处的状况。状况也就是环境，是不断变化的，所以状态也是不断变化的。 需要注意的是: 状态是由事物自行处理的，不断变化的。跟属性不一样，属性是天生具备的，事物没办法去直接修改。但是状态是事物可以直接进行操作的。 在 React 中，状态是事物的私有属性，一个事物的状态怎么样，都是由事物自己去决定的，他的父组件和子组件都没有权利也没有能力去修改它的状态。 状态的用法:一、constructor: 初始化每个实例特有的状态二、setState: setState 是 React 提供的函数，通过它可以更新组件的状态。 相比属性来说，状态的用法比较简单。 属性与状态的对比通过上面我们了解到了属性和状态的含义和用法。那么属性和状态有什么相似点或者不同点呢？ 属性和状态的相似点: 都是纯JS对象 他们都会触发 render 更新组件 都具有确定性 第一种: 纯 JS 对象，就是JS原生对象，在JS中还有宿主对象，例如 window，其实就是浏览器提供的宿主对象，并不是原生对象。属性和状态就是 JS 原生对象。 第二种: 状态和属性的变化都会触发 render 的更新。属性和状态的改变都会触发组件的整个流程，从处理属性到是否应该更新，到进行对比到最后的render 更新，会触发很多函数，我们可以在不同的函数中进行不同的操作。 第三种: 属性和状态都具有确定性。状态相同结果一定相同。也就是说给定了相同的状态或者属性，组件生成的应该都是相同的代码。 属性和状态的对比: - 属性 状态 能否从父组件获取初始值？ √ × 能否由父组件修改？ √ × 能否在组件内部设置默认值？ √ √ 能否在组件内部修改？ × √ 能否设置子组件的初始值？ √ × 能否修改子组件的值？ √ × 区分属性和状态有一种简单的办法: 就是看属性和状态保存的数据是否需要在运行时修改，如果运行时组件需要修改这个数据，那么这个数据就一定是状态。除此之外的所有数据都可以设置为属性。 元素与组件元素:React 中，元素是最小的基本单位，使用 JSX 语法可以创建一个 React 元素。 const element = &lt;div className=&apos;element&apos;&gt;&lt;/div&gt; React 元素代表所有你在屏幕上看到的东西。React 通过读取这些元素来构建 DOM 并保持数据内容一致。React 元素不是真实的 DOM 元素，它仅仅是 js 的普通对象。也可以用 React.createElement() 方法来构建 React 元素。 组件:组件是什么？组件是由元素构成的，React 中使用组件来封装界面模块，整个界面就是一个大的组件，我们在开发过程中不断优化和拆分界面组件。 组件的类型React 推出后，由于不同的原因，出现了三种定义 React 组件的方式。 函数式定义的无状态组件 使用es5原生方式 React.createClass 定义的组件 使用es6形式的 extends React.Component 定义的组件 上面三种组件有什么区别呢？ 一、无状态组件 顾名思义，无状态组件就是无状态的组件。它是为了创建纯展示组件，这种组件只负责根据传入的 props 来展示，不涉及到 state 的操作。 function SayHello (props) { return &lt;div&gt;Hello, { props.name }&lt;/div&gt; } ReactDOM.render(&lt;SayHello name=&apos;Tom&apos; /&gt;, document.body) 无状态组件的创建让代码可读性更高，并且减少了更多的多余代码，只有一个 render 方法，极大的增强了编写组件的便利。由于是无状态组件，所以不会被实例化，这样也会让性能得到一定的提升。但是不能访问 this 对象，同样因为不需要组件生命周期管理和状态管理，所以该组件无法访问生命周期的方法。 二、React.createClass React.createClass 是 React 最开始推荐的创建组件的方式，使用ES5的JavaScript 来实现的 React 组件，同时也是三种方式最早，兼容性最好的方法。 var Greeting = React.createClass({ render: function() { return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;; } }); 与无状态组件相比，React.createClass 是创建有状态的组件，可以访问组件的生命周期方法，但是随着时间，也有一些问题暴露出来: 会自绑定函数方法，导致不必要的性能开销，增加代码过时的可能性。 React.createClass 的 mixins 不够自然、直观。相比它 React.Component 更适合高阶组件，并且由于高阶组件是纯净的JavaScript，所以不用担心它们会被废弃。 三、React.Component React.Component 是以ES6的形式来创建 React 组件的，是目前 React 推荐的创建有状态组件的方式。相比较与第二种方法，React.Component 可以很好的实现代码的复用。 class Greeting extemds React.Component{ render () { return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;; } };","path":"2018/01/31/React笔记/","date":"01-31","excerpt":""},{"title":"Rollup 新一代打包工具？","text":"什么是 Rollup?用 Rollup 团队自己的话来将是: Rollup 是下一代 JavaScript 模块打包工具。开发者可以在你的应用或库中使用 ES2015 模块，然后高效地将它们打包成一个单一文件用于浏览器和 Node.js 使用。 Rollup 的闪光点Rollup 最让我们程序猿激动的地方就是能让打包文件体积很小。小到什么地步呢？相比其他 JavaScript 打包工具，Rollup 能打包出更小、更快的包。因为 Rollup 是基于 ES2015 模块，比 CommonJS 模块机制更高效。正因如此，Rollup 的 tree-shaking 也变得更加容易( 只能对 ES 模块进行 tree-shaking )。然而 tree-shaking 并不是 Rollup 在与其他打包工具相比的唯一的优势。 由于 Rollup 很高效，Webpack2 也支持 tree-shaking 使用 Rollup 处理并打包 JavaScript 文件安装 Rollup:首先，新建一个文件夹并全局安装 rollup npm i -g rollup 下一步: 执行下列命令: npm init -ynpm i rollup 然后，在当前文件夹下新建 rollup.config.js 文件，并在文件添加以下内容: export default { entry: &apos;main.js&apos;, output: { file: &apos;main.min.js&apos;, format: &apos;cjs&apos; } } entry: 希望 Rollup 处理的文件路径。作为入口文件，初始化所有东西并启动应用。 file: 编译之后的文件存放的路径。 format: Rollup 输出格式。包括( amd / es6 / iife / umd ) 来看一下入口文件 main.js : import { cube } from &apos;./math.js&apos;; console.log( cube( 5 ) ); 被引入文件 math.js 为: export function square (x) { return x * x; } export function cube (x) { return x * x * x; } 通过 Rollup 打包之后为: &apos;use strict&apos;; function cube (x) { return x * x * x; } console.log( cube( 5 ) ); 这里可以明显的看到 Rollup 中 Tree-shaking 的作用了，在我们创建的 math.js 文件中并未用到的 square 方法，在使用 Rollup 打包之后被干掉了。 到这里，安装和文件都已经准备好了，让我们来运行它: ./node_modules/.bin/rollup main.js -f cjs 因为我们并没有使用配置文件，所以输入上述命令，打包之后的内容会显示在终端上。我们当然也可以使用配置文件: ./node_modules/.bin/rollup -c 如果你的配置文件名并不是 rollup.config.js 的话( 例如: ‘rollup.config.dev.js’ ) ./node_modules/.bin/rollup -c rollup.config.dev.js","path":"2018/01/30/Rollup/","date":"01-30","excerpt":""},{"title":"Less, Sass和Stylus","text":"Less, Sass和StylusLESSLESS 做为 CSS 的一种形式的扩展，在现有的 CSS 语法上，添加了很多额外的功能，拥有诸如 Sass 和 Stylus 之类的预处理器，它们也给我们提供了许多优于纯 CSS 的好处。 变量 - 它可以让你更轻松的在整个样式表中定义和更改值 Mixins - 可以让你重用或者组合样式，而且支持传递参数。 函数 - 它为你提供了一些方便的程序去操纵颜色，转换图像等。 变量我们可以用 @ 来声明一个变量来保存需要的样式 @nice-blue: #5B83AD;@light-blue: @nice-blue + #111; .header { color: @light-blue; } 转译输出后: .header { color: #6c94be; } 当然也可以用已定义的变量来为其他变量定义: @str: “I am str.”;@var: ‘str’;content: @@var; 转译输出后: content: “I am str.”; *请注意 LESS 中的变量为 “常量” ，所以只能定义一次.* 混合在 LESS 中我们可以将一些通用的属性集定义，然后在其他标签中去调用这个属性集. .border { border-top: solid 1px red; border-bottom: solid 2px black;} 那如果我们现在需要在其他标签中引入这个属性集，那么我们只需要在任何标签中调用就可以了: menu a { color: #111; .border;}.post a { color: red; .border;} .border 里面的属性样式就会在 #menu a 和 .post a中体现出来。转译输出后: menu a { color: #111; border-top: solid 1px red; border-bottom: solid 2px black;}.post a { color: blue; border-top: solid 1px red; border-bottom: solid 2px black;} 任何 CSS class, id 或者 元素 属性集都可以以同样的方式引入. 带参数混合在 LESS 中，你还可以像函数一样定义一个带参数的属性集合,它支持传入参数 .border-radius (@radius) { border-radius: @radius; -moz-border-radius: @radius; -webkit-border-radius: @radius;} 然后像这样调用: header { .border-radius(4px);}.button { .border-radius(6px);} 我们还可以给参数设置默认值: .border-radius (@radius: 5px) { border-radius: @radius; -moz-border-radius: @radius; -webkit-border-radius: @radius;} 所以现在如果像这样调用的话: header { .border-radius;} radius的值就会是5px. 嵌套 ul { background-color: #03A9F4; padding: 10px; list-style: none; li { background-color: #fff; border-radius: 3px; margin: 10px 0; }} 编译成 CSS 代码： ul { background-color: #03A9F4; padding: 10px; list-style: none;}ul li { background-color: #fff; border-radius: 3px; margin: 10px 0;} 就像在其它高级语言中一样， Less 的变量根据范围接受它们的值。如果在指定范围内没有关于变量值的声明， less 会一直往上查找，直至找到离它最近的声明。 StylusStylus 与 Less 同样是 css 的预处理器。它没有封号、花括号、逗号也是可以执行的。 例如： p margin 0 padding 0 编译后为： p { margin: 0; padding: 0;} 变量Stylus 中也可以将常用的参数定义为变量，在需要的地方直接引用变量即可 例如： font-size = 16px //单一变量font = 12px/16px ‘微软雅黑’ //变量表达式$width = 16px //可以带标示符 a font font //直接引用单一变量 width $width //直接引用变量表达式 margin-left (@width/2) //可以用@来访问该属性当前对应的值 转译后为： a { font: 0.75px ‘微软雅黑’; width: 16px; margin-left: 8px;} Stylus 中也可用 HTML 结构来表现 CSS 层级关系 body color red ul line-height 20px height 20px font-size 16px li display inline-block padding 10px border 1px solid #ccc text-align center a color red font-size 12px 转译后为： body { color: #f00;}body ul { line-height: 20px; height: 20px; font-size: 16px;}body ul li { display: inline-block; padding: 10px; border: 1px solid #ccc; text-align: center;}body ul li a { color: #f00; font-size: 12px;} SASSSASS 的使用与前两者大体相同，在 SASS 中我们也可以来声明一个变量 $base-gap: 10px;$base-color: #333;.test { margin-top: $base-gap; color: $base-color;} 在这里我们能看到 SASS 声明变量与 LESS 和 Stylus 还是有不同的，在LESS 中，我们用 @ 符号来声明一个变量，在 Stylus 中，我们也可以用 @ 符号或者什么都不用。而在 SASS中 我们需要用 $ 符号来声明变量 在 SASS 中有默认变量这一说法：如果这个变量被声明赋值了，那就用它声明的值，否则就用默认值。这在书写 SASS 库文件时非常有用。设置默认变量的方法也非常简单，只需在变量值后加上 !default $color: #ccc;$color: #000 !default;p { color: $color;} 嵌套方法 .list { margin-top: 10;}.list li { padding-left: 15px;}.list a { color: #333;}.list a:hover { text-decoration: none;} 用嵌套方法写就是： .list { margin-top: 10px; li { padding-left: 15px; } a { color: #333; &amp;:hover { text-decoration: none; } }} 嵌套代码中的 &amp; 表示父元素选择器。 下载方法LESS：npm install -g less 安装完成后，你将可以在任何打开的窗口中使用 lessc 命令，这个命令允许你将 .less 文件编译成纯 CSS 文件，像下面这样： lessc styles.less &gt; styles.css Stylus：npm install -g stylus 建立一个stylusExample/，再在里面建立 src 目录专门存放 stylus 文件，在里面建立 example.styl 文件。然后在 stylusExample 目录下面执行下面命令 stylus --compress src/ 输出 compiled src/example.css ，这个时候表示你生成成功了，带上 –compress 参数表示你生成压缩的CSS文件。 stylus --css css/example.css css/out.styl CSS转换成stylstylus help box-shadow CSS属性的帮助stylus --css test.css 输出基本名一致的.styl文件 SASSSass 基于 Ruby 编写，所以安装 Sass 分2步：先安装Ruby的环境，再安装Sass。 一、在 Ruby 官网选择电脑系统对应的版本下载、安装，建议默认路径即可。安装过程中注意勾选第二项：Add Ruby executablesto your PATH。安装完毕在命令行环境中通过 ruby -v 查看是否成功。 二、Ruby安装成功之后，它自带的包管理工具 gem 也就安装好了。直接打开命令行通过gem 执行 Sass 安装命令，再查看是否安装成功： gem install sass sass -v 查看是否安装成功 经过简单的了解和尝试后，我比较喜欢 Stylus 得益于以下几点： 简短直观，缩进让CSS的层次非常直观 @ 属性引用可以减少维护量 函数和Mixin，重用的利器","path":"2018/01/13/Less, Sass和Stylus/","date":"01-13","excerpt":""},{"title":"first","text":"欢迎来到我的个人技术博客","path":"2018/01/13/first/","date":"01-13","excerpt":""},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2018/01/13/hello-world/","date":"01-13","excerpt":""}]}